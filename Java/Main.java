package Java;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Main.java
 * 
 * This driver program reads input files (generated by DataGenerator.java) for three case types:
 * AVERAGE, BEST, and WORST. For each case type and for each input size (100, 1000, 5000, 10000),
 * it runs the First Fit Decreasing (FFD) algorithm, measures its execution time and the number of bins used.
 * For the FF algorithm, the result is recorded as "N/A" (since it is not implemented yet).
 * 
 * The results are written to a CSV file ("results.csv") placed in the same folder as Main.java.
 * The CSV output for each case type is in the following format:
 * 
 * [Timestamp] [CASE TYPE] CASE				
 *     FF (time),FFD (time),FF (bins),FFD (bins)
 * 100,N/A,[FFD time],[FFD bins]
 * 1000,N/A,[FFD time],[FFD bins]
 * 5000,N/A,[FFD time],[FFD bins]
 * 10000,N/A,[FFD time],[FFD bins]
 * 				
 * 				
 * (Two blank lines separate each block.)
 * 
 * After processing, the only terminal output is:
 * "Algorithms tested and recorded in results.csv"
 */
public class Main {
    // Fixed bin capacity.
    public static final int BIN_CAPACITY = 10;
    
    // CSV file path is set to "Java/results.csv" so it appears in the Java folder.
    public static final String CSV_FILE = "Java" + File.separator + "results.csv";
    
    // Input sizes and case types.
    public static final int[] SIZES = {100, 1000, 5000, 10000};
    public static final String[] CASES = {"average", "best", "worst"};

    public static void main(String[] args) {
        // Build separate lists for each case type.
        ArrayList<String> avgFiles = new ArrayList<>();
        ArrayList<String> bestFiles = new ArrayList<>();
        ArrayList<String> worstFiles = new ArrayList<>();
        for (int size : SIZES) {
            avgFiles.add(size + "_average.txt");
            bestFiles.add(size + "_best.txt");
            worstFiles.add(size + "_worst.txt");
        }
        
        // Build a CSV block string for all three case types.
        StringBuilder csvBlock = new StringBuilder();
        
        // Get current timestamp formatted as "M/d/yyyy hh:mm:ss a"
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("M/d/yyyy hh:mm:ss a");
        String timestamp = LocalDateTime.now().format(formatter);
        
        // Process each case type in order.
        csvBlock.append(generateCSVBlock("AVERAGE", timestamp, avgFiles));
        csvBlock.append(generateCSVBlock("BEST", timestamp, bestFiles));
        csvBlock.append(generateCSVBlock("WORST", timestamp, worstFiles));
        
        // Append the CSV block to the results CSV file.
        appendCSVBlock(csvBlock.toString());
        
        // Terminal output: only one message.
        System.out.println("Algorithms tested and recorded in results.csv");
    }
    
    /**
     * Generates a CSV block for a given case type.
     * The block includes a header with the timestamp and case type, a row for column headers,
     * and one row per input file (for each size). For FF, both time and bins are "N/A".
     * For FFD, the algorithm is run and its execution time and bins used are recorded.
     *
     * @param caseType   The case type (e.g., "AVERAGE", "BEST", "WORST").
     * @param timestamp  The timestamp string.
     * @param fileList   A list of file names corresponding to the case type.
     * @return           A string representing the CSV block.
     */
    public static String generateCSVBlock(String caseType, String timestamp, ArrayList<String> fileList) {
        StringBuilder block = new StringBuilder();
        // Header line with timestamp and case type.
        block.append(timestamp).append(" ").append(caseType).append(" CASE").append("\n");
        // Column header: blank first column then FF (time), FFD (time), FF (bins), FFD (bins)
        block.append(",FF (time),FFD (time),FF (bins),FFD (bins)").append("\n");
        
        // For each file in the list, extract the size from the file name.
        for (String fileName : fileList) {
            // Extract the size (substring before the underscore)
            String sizeStr = fileName.split("_")[0];
            int size = Integer.parseInt(sizeStr);
            int[] items = readItemsFromFile(fileName);
            
            // Default values: if reading fails, leave as "N/A"
            String ffdTime = "N/A";
            String ffdBins = "N/A";
            if (items != null) {
                // Run FFD algorithm and measure execution time.
                long startTime = System.nanoTime();
                int binsUsed = FFD.firstFitDecreasing(items, BIN_CAPACITY);
                long endTime = System.nanoTime();
                double durationMillis = (endTime - startTime) / 1e6; // Convert nanoseconds to ms.
                ffdTime = String.format("%.3f", durationMillis);
                ffdBins = String.valueOf(binsUsed);
            }
            // FF values remain "N/A"
            String ffTime = "N/A";
            String ffBins = "N/A";
            
            // Append a row: size, FF (time), FFD (time), FF (bins), FFD (bins)
            block.append(size).append(",").append(ffTime).append(",").append(ffdTime)
                 .append(",").append(ffBins).append(",").append(ffdBins).append("\n");
        }
        // Append two blank lines to separate blocks.
        block.append("\n\n");
        return block.toString();
    }
    
    /**
     * Reads item sizes from a text file.
     * Each line in the file should contain a single integer.
     *
     * @param fileName the name of the file to read.
     * @return an array of integers read from the file; returns null if file not found.
     */
    public static int[] readItemsFromFile(String fileName) {
        ArrayList<Integer> list = new ArrayList<>();
        try (Scanner sc = new Scanner(new File(fileName))) {
            while (sc.hasNextLine()) {
                String line = sc.nextLine().trim();
                if (!line.isEmpty()) {
                    list.add(Integer.parseInt(line));
                }
            }
        } catch (FileNotFoundException e) {
            System.err.println("File not found: " + fileName);
            return null;
        }
        int[] items = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            items[i] = list.get(i);
        }
        return items;
    }
    
    /**
     * Appends the provided CSV block (a multiline string) to the CSV file.
     * The CSV file will be created (or appended to) in the same folder as Main.java.
     *
     * @param csvBlock the CSV text block to append.
     */
    public static void appendCSVBlock(String csvBlock) {
        try (PrintWriter csvWriter = new PrintWriter(new FileWriter(CSV_FILE, true))) {
            csvWriter.print(csvBlock);
        } catch (IOException e) {
            System.err.println("Error writing to CSV file: " + e.getMessage());
        }
    }
}
