package Java;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Main.java
 * 
 * This driver program processes input files (generated by DataGenerator.java) for three case types:
 * AVERAGE, BEST, and WORST. For each case type and for each input size (100, 1000, 5000, 10000),
 * it runs both the FF and FFD algorithms, measures their execution time and the number of bins used.
 * 
 * The results are appended to a CSV file ("results.csv") located in the same folder as Main.java.
 * The CSV output for each case type is in the following format:
 * 
 * [Timestamp] [CASE TYPE] CASE
 * ,FF (time),FFD (time),FF (bins),FFD (bins)
 * 100,[FF time],[FFD time],[FF bins],[FFD bins]
 * 1000,[FF time],[FFD time],[FF bins],[FFD bins]
 * 5000,[FF time],[FFD time],[FF bins],[FFD bins]
 * 10000,[FF time],[FFD time],[FF bins],[FFD bins]
 * 
 * (One blank line separates each block.)
 * 
 * The only terminal output is:
 * "Algorithms tested and recorded in results.csv"
 */
public class Main {
    // Fixed bin capacity.
    public static final int BIN_CAPACITY = 10;
    // CSV file is placed in the same folder as Main.java.
    public static final String CSV_FILE = "Java" + File.separator + "results.csv";
    // Input sizes and case types.
    public static final int[] SIZES = {100, 1000, 5000, 10000};
    public static final String[] CASES = {"average", "best", "worst"};

    public static void main(String[] args) {
        // StringBuilder to collect CSV results.
        StringBuilder csvBlock = new StringBuilder();
        
        // Get the current timestamp formatted as "M/d/yyyy hh:mm:ss a"
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("M/d/yyyy hh:mm:ss a");
        String timestamp = LocalDateTime.now().format(formatter);
        
        // Process each case type.
        for (String caseType : CASES) {
            // Append header line for the case block.
            csvBlock.append(timestamp)
                .append(" --- ")
                .append(caseType.toUpperCase())
                .append(" CASE")
                .append("\n");
            // Append the column headers.
            csvBlock.append(",FF (time),FFD (time),FF (bins),FFD (bins)").append("\n");
            
            // For each input size, construct the filename and process.
            for (int size : SIZES) {
                String fileName = size + "_" + caseType + ".txt";
                int[] items = readItemsFromFile(fileName);
                
                String ffTime = "N/A";
                String ffdTime = "N/A";
                String ffBins = "N/A";
                String ffdBins = "N/A";
                
                if (items != null) {
                    // Run FF algorithm and measure time.
                    long startFF = System.nanoTime();
                    int ffResult = FF.firstFit(items, BIN_CAPACITY);
                    long endFF = System.nanoTime();
                    double durationFF = (endFF - startFF) / 1e6; // Convert to milliseconds.
                    
                    // Run FFD algorithm and measure time.
                    long startFFD = System.nanoTime();
                    int ffdResult = FFD.firstFitDecreasing(items, BIN_CAPACITY);
                    long endFFD = System.nanoTime();
                    double durationFFD = (endFFD - startFFD) / 1e6; // Convert to milliseconds.
                    
                    ffTime = String.format("%.3f", durationFF);
                    ffdTime = String.format("%.3f", durationFFD);
                    ffBins = String.valueOf(ffResult);
                    ffdBins = String.valueOf(ffdResult);
                }
                
                // Append a row with the results.
                csvBlock.append(size).append(",").append(ffTime).append(",").append(ffdTime)
                        .append(",").append(ffBins).append(",").append(ffdBins).append("\n");
            }
            // Append one blank line between case blocks.
            csvBlock.append("\n");
        }
        
        // Append the CSV block to the results CSV file.
        appendCSVBlock(csvBlock.toString());
        
        // Only terminal output.
        System.out.println("Algorithms tested and recorded in results.csv");
    }
    
    /**
     * Reads item sizes from a text file.
     * Each line should contain a single integer.
     *
     * @param fileName the name of the file to read.
     * @return an array of integers read from the file; null if an error occurs.
     */
    public static int[] readItemsFromFile(String fileName) {
        ArrayList<Integer> list = new ArrayList<>();
        try (Scanner sc = new Scanner(new File(fileName))) {
            while (sc.hasNextLine()) {
                String line = sc.nextLine().trim();
                if (!line.isEmpty()) {
                    list.add(Integer.parseInt(line));
                }
            }
        } catch (FileNotFoundException e) {
            System.err.println("File not found: " + fileName);
            return null;
        }
        int[] items = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            items[i] = list.get(i);
        }
        return items;
    }
    
    /**
     * Appends the given CSV block (multiline string) to the CSV file.
     * The file is created in the same folder as Main.java.
     *
     * @param csvBlock the CSV text block to append.
     */
    public static void appendCSVBlock(String csvBlock) {
        try (PrintWriter writer = new PrintWriter(new FileWriter(CSV_FILE, true))) {
            writer.print(csvBlock);
        } catch (IOException e) {
            System.err.println("Error writing to CSV file: " + e.getMessage());
        }
    }
}
